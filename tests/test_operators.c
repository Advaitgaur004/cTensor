#include "test_framework.h"

// Hardcoded reference data from PyTorch
// This data is generated by generate_reference_data.py

/**
 * @brief Tests element-wise addition of two tensors.
 *
 * Creates two tensors with predefined values, performs element-wise addition, and asserts that the result matches the expected output.
 *
 * @return true if the addition result matches the expected values.
 */
bool test_tensor_add(void) {
    // Reference data from PyTorch
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float input_b[] = {0.5f, 1.5f, 2.5f, 3.5f};
    float expected[] = {1.5f, 3.5f, 5.5f, 7.5f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input_a, false);
    Tensor b = create_tensor_from_data(shape, input_b, false);
    
    Tensor result = Tensor_add(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor addition failed");
    return true;
}

/**
 * @brief Tests element-wise subtraction of two tensors.
 *
 * Creates two tensors with predefined values, performs element-wise subtraction, and asserts that the result matches the expected output.
 *
 * @return true if the subtraction result matches the expected values.
 */
bool test_tensor_sub(void) {
    // Reference data from PyTorch
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float input_b[] = {0.5f, 1.5f, 2.5f, 3.5f};
    float expected[] = {0.5f, 0.5f, 0.5f, 0.5f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input_a, false);
    Tensor b = create_tensor_from_data(shape, input_b, false);
    
    Tensor result = Tensor_sub(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor subtraction failed");
    return true;
}

/**
 * @brief Tests element-wise multiplication of two tensors of shape (4).
 *
 * Creates two tensors from fixed input arrays, multiplies them element-wise, and asserts that the result matches the expected output.
 *
 * @return true if the test passes.
 */
bool test_tensor_mul(void) {
    // Reference data from PyTorch
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float input_b[] = {0.5f, 1.5f, 2.5f, 3.5f};
    float expected[] = {0.5f, 3.0f, 7.5f, 14.0f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input_a, false);
    Tensor b = create_tensor_from_data(shape, input_b, false);
    
    Tensor result = Tensor_mul(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor multiplication failed");
    return true;
}

/**
 * @brief Tests element-wise addition of a scalar to a tensor.
 *
 * Creates a tensor from a fixed input array, adds a scalar value to each element, and asserts that the result matches the expected output.
 *
 * @return true if the test passes.
 */
bool test_tensor_add_scalar(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float scalar = 2.5f;
    float expected[] = {3.5f, 4.5f, 5.5f, 6.5f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_addf(a, scalar);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor scalar addition failed");
    return true;
}

/**
 * @brief Tests element-wise multiplication of a tensor by a scalar.
 *
 * Creates a tensor from reference data, multiplies each element by a scalar, and asserts that the result matches expected values.
 *
 * @return true if the test passes.
 */
bool test_tensor_mul_scalar(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float scalar = 2.5f;
    float expected[] = {2.5f, 5.0f, 7.5f, 10.0f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_mulf(a, scalar);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor scalar multiplication failed");
    return true;
}

/**
 * @brief Tests matrix multiplication of two tensors with shapes (2x3) and (3x2).
 *
 * Creates tensors from fixed input arrays, performs matrix multiplication, and asserts that the result matches the expected (2x2) output.
 *
 * @return true if the matrix multiplication produces the correct result; otherwise, the test fails via assertion.
 */
bool test_tensor_matmul(void) {
    // Reference data from PyTorch
    // a: 2x3, b: 3x2, result: 2x2
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float input_b[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float expected[] = {22.0f, 28.0f, 49.0f, 64.0f};
    
    TensorShape shape_a = {2, 3, 0, 0};
    TensorShape shape_b = {3, 2, 0, 0};
    
    Tensor a = create_tensor_from_data(shape_a, input_a, false);
    Tensor b = create_tensor_from_data(shape_b, input_b, false);
    
    Tensor result = Tensor_matmul(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Matrix multiplication failed");
    return true;
}

/**
 * @brief Tests the summation of all elements in a tensor.
 *
 * Creates a tensor with shape (2, 3), computes the sum of its elements, and asserts that the result matches the expected value.
 *
 * @return true if the test passes.
 */
bool test_tensor_sum(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float expected[] = {21.0f};
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_sum(a);
    
    ASSERT_TENSOR_EQ(expected, result, 1, "Tensor sum failed");
    return true;
}

/**
 * @brief Tests the mean calculation of all elements in a tensor.
 *
 * Creates a tensor with shape (2, 3), computes the mean of its elements, and asserts that the result matches the expected value.
 *
 * @return true if the mean calculation is correct.
 */
bool test_tensor_mean(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float expected[] = {3.5f};
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_mean(a);
    
    ASSERT_TENSOR_EQ(expected, result, 1, "Tensor mean failed");
    return true;
}

/**
 * @brief Tests the argmax operation along the last dimension of a 2x3 tensor.
 *
 * Creates a tensor with predefined values, computes the index of the maximum value along the last dimension for each row, and asserts that the result matches the expected indices.
 *
 * @return true if the argmax operation produces the expected result.
 */
bool test_tensor_argmax(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    int expected[] = {2, 2};  // argmax along last dimension
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    int result[2];
    Tensor_argmax(a, result);
    
    ASSERT_TRUE(result[0] == expected[0] && result[1] == expected[1], 
                "Tensor argmax failed");
    return true;
}

/**
 * @brief Tests the ReLU activation function on a 1D tensor.
 *
 * Creates a tensor with both negative and positive values, applies the ReLU activation, and asserts that the output matches the expected result where all negative values are replaced with zero.
 *
 * @return true Always returns true after assertion.
 */
bool test_nn_relu(void) {
    // Reference data from PyTorch
    float input[] = {-2.0f, -1.0f, 0.0f, 1.0f, 2.0f, 3.0f};
    float expected[] = {0.0f, 0.0f, 0.0f, 1.0f, 2.0f, 3.0f};
    TensorShape shape = {6, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = nn_relu(a);
    
    ASSERT_TENSOR_EQ(expected, result, 6, "ReLU activation failed");
    return true;
}

/**
 * @brief Tests the softmax activation function on a 2x3 tensor.
 *
 * Verifies that applying softmax to a tensor produces the expected output by comparing results to reference values from PyTorch.
 *
 * @return true if the softmax output matches the expected values.
 */
bool test_nn_softmax(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    // PyTorch softmax output for [[1,2,3], [4,5,6]]
    float expected[] = {0.090031f, 0.244728f, 0.665241f, 0.090031f, 0.244728f, 0.665241f};
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = nn_softmax(a);
    
    ASSERT_TENSOR_EQ(expected, result, 6, "Softmax activation failed");
    return true;
}

/**
 * @brief Tests the cross-entropy loss computation between one-hot encoded true labels and predicted probabilities.
 *
 * Creates tensors for true labels and predicted probabilities, computes the cross-entropy loss, and asserts that the result matches the expected reference value.
 *
 * @return true if the computed loss matches the expected value; otherwise, the test fails via assertion.
 */
bool test_nn_crossentropy(void) {
    // Reference data from PyTorch
    float y_true[] = {0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f};  // One-hot encoded
    float y_pred[] = {0.1f, 0.2f, 0.7f, 0.8f, 0.1f, 0.1f};  // Predicted probabilities
    float expected[] = {0.223776f};  // Cross-entropy loss
    
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor true_tensor = create_tensor_from_data(shape, y_true, false);
    Tensor pred_tensor = create_tensor_from_data(shape, y_pred, false);
    
    Tensor result = nn_crossentropy(true_tensor, pred_tensor);
    
    ASSERT_TENSOR_EQ(expected, result, 1, "Cross-entropy loss failed");
    return true;
}

/**
 * @brief Tests the correctness of the linear neural network layer operation.
 *
 * Creates input, weight, and bias tensors with predefined values, applies the linear transformation, and asserts that the output matches the expected result.
 *
 * @return true Always returns true after performing the assertion.
 */
bool test_nn_linear(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};  // 2x3
    float weight[] = {0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f};  // 3x2
    float bias[] = {0.1f, 0.2f};  // 2
    float expected[] = {1.5f, 1.8f, 3.3f, 4.2f};  // 2x2
    
    TensorShape input_shape = {2, 3, 0, 0};
    TensorShape weight_shape = {3, 2, 0, 0};
    TensorShape bias_shape = {2, 0, 0, 0};
    
    Tensor input_tensor = create_tensor_from_data(input_shape, input, false);
    Tensor weight_tensor = create_tensor_from_data(weight_shape, weight, false);
    Tensor bias_tensor = create_tensor_from_data(bias_shape, bias, false);
    
    Tensor result = nn_linear(input_tensor, weight_tensor, bias_tensor);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Linear layer failed");
    return true;
}

/**
 * @brief Runs unit tests for tensor arithmetic operations.
 *
 * Executes tests for element-wise addition, subtraction, multiplication, scalar addition, and scalar multiplication on tensors.
 *
 * @return true Always returns true after running all arithmetic operation tests.
 */
bool test_arithmetic_operations(void) {
    printf("=== Testing Arithmetic Operations ===\n");
    
    RUN_TEST(test_tensor_add);
    RUN_TEST(test_tensor_sub);
    RUN_TEST(test_tensor_mul);
    RUN_TEST(test_tensor_add_scalar);
    RUN_TEST(test_tensor_mul_scalar);
    
    return true;
}

/**
 * @brief Runs the unit test for tensor matrix multiplication operations.
 *
 * Executes the test for matrix multiplication and prints a header indicating the test category.
 *
 * @return true Always returns true after running the test.
 */
bool test_matrix_operations(void) {
    printf("=== Testing Matrix Operations ===\n");
    
    RUN_TEST(test_tensor_matmul);
    
    return true;
}

/**
 * @brief Runs unit tests for tensor reduction operations.
 *
 * Executes tests for summation, mean, and argmax functions on tensors to verify correctness of reduction operations.
 *
 * @return true Always returns true after running the tests.
 */
bool test_reduction_operations(void) {
    printf("=== Testing Reduction Operations ===\n");
    
    RUN_TEST(test_tensor_sum);
    RUN_TEST(test_tensor_mean);
    RUN_TEST(test_tensor_argmax);
    
    return true;
}

/**
 * @brief Runs unit tests for neural network activation functions.
 *
 * Executes tests for ReLU and softmax activations to verify their correctness.
 *
 * @return true if all activation function tests pass.
 */
bool test_activation_functions(void) {
    printf("=== Testing Activation Functions ===\n");
    
    RUN_TEST(test_nn_relu);
    RUN_TEST(test_nn_softmax);
    
    return true;
}

/**
 * @brief Runs unit tests for neural network loss functions.
 *
 * Executes the test for cross-entropy loss and reports the results.
 *
 * @return true Always returns true after running the tests.
 */
bool test_loss_functions(void) {
    printf("=== Testing Loss Functions ===\n");
    
    RUN_TEST(test_nn_crossentropy);
    
    return true;
}

/**
 * @brief Runs unit tests for neural network operations.
 *
 * Executes tests related to neural network layers and returns true upon completion.
 *
 * @return true Always returns true after running the tests.
 */
bool test_neural_network_operations(void) {
    printf("=== Testing Neural Network Operations ===\n");
    
    RUN_TEST(test_nn_linear);
    
    return true;
}