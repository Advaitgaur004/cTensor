#include "test_framework.h"

// Hardcoded reference data from PyTorch
// This data is generated by generate_reference_data.py

// Test data for arithmetic operations
bool test_tensor_add(void) {
    // Reference data from PyTorch
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float input_b[] = {0.5f, 1.5f, 2.5f, 3.5f};
    float expected[] = {1.5f, 3.5f, 5.5f, 7.5f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input_a, false);
    Tensor b = create_tensor_from_data(shape, input_b, false);
    
    Tensor result = Tensor_add(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor addition failed");
    return true;
}

bool test_tensor_sub(void) {
    // Reference data from PyTorch
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float input_b[] = {0.5f, 1.5f, 2.5f, 3.5f};
    float expected[] = {0.5f, 0.5f, 0.5f, 0.5f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input_a, false);
    Tensor b = create_tensor_from_data(shape, input_b, false);
    
    Tensor result = Tensor_sub(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor subtraction failed");
    return true;
}

bool test_tensor_mul(void) {
    // Reference data from PyTorch
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float input_b[] = {0.5f, 1.5f, 2.5f, 3.5f};
    float expected[] = {0.5f, 3.0f, 7.5f, 14.0f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input_a, false);
    Tensor b = create_tensor_from_data(shape, input_b, false);
    
    Tensor result = Tensor_mul(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor multiplication failed");
    return true;
}

bool test_tensor_add_scalar(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float scalar = 2.5f;
    float expected[] = {3.5f, 4.5f, 5.5f, 6.5f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_addf(a, scalar);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor scalar addition failed");
    return true;
}

bool test_tensor_mul_scalar(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f};
    float scalar = 2.5f;
    float expected[] = {2.5f, 5.0f, 7.5f, 10.0f};
    TensorShape shape = {4, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_mulf(a, scalar);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Tensor scalar multiplication failed");
    return true;
}

bool test_tensor_matmul(void) {
    // Reference data from PyTorch
    // a: 2x3, b: 3x2, result: 2x2
    float input_a[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float input_b[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float expected[] = {22.0f, 28.0f, 49.0f, 64.0f};
    
    TensorShape shape_a = {2, 3, 0, 0};
    TensorShape shape_b = {3, 2, 0, 0};
    
    Tensor a = create_tensor_from_data(shape_a, input_a, false);
    Tensor b = create_tensor_from_data(shape_b, input_b, false);
    
    Tensor result = Tensor_matmul(a, b);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Matrix multiplication failed");
    return true;
}

bool test_tensor_sum(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float expected[] = {21.0f};
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_sum(a);
    
    ASSERT_TENSOR_EQ(expected, result, 1, "Tensor sum failed");
    return true;
}

bool test_tensor_mean(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    float expected[] = {3.5f};
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = Tensor_mean(a);
    
    ASSERT_TENSOR_EQ(expected, result, 1, "Tensor mean failed");
    return true;
}

bool test_tensor_argmax(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    int expected[] = {2, 2};  // argmax along last dimension
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    int result[2];
    Tensor_argmax(a, result);
    
    ASSERT_TRUE(result[0] == expected[0] && result[1] == expected[1], 
                "Tensor argmax failed");
    return true;
}

bool test_nn_relu(void) {
    // Reference data from PyTorch
    float input[] = {-2.0f, -1.0f, 0.0f, 1.0f, 2.0f, 3.0f};
    float expected[] = {0.0f, 0.0f, 0.0f, 1.0f, 2.0f, 3.0f};
    TensorShape shape = {6, 0, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = nn_relu(a);
    
    ASSERT_TENSOR_EQ(expected, result, 6, "ReLU activation failed");
    return true;
}

bool test_nn_softmax(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
    // PyTorch softmax output for [[1,2,3], [4,5,6]]
    float expected[] = {0.090031f, 0.244728f, 0.665241f, 0.090031f, 0.244728f, 0.665241f};
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor a = create_tensor_from_data(shape, input, false);
    
    Tensor result = nn_softmax(a);
    
    ASSERT_TENSOR_EQ(expected, result, 6, "Softmax activation failed");
    return true;
}

bool test_nn_crossentropy(void) {
    // Reference data from PyTorch
    float y_true[] = {0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f};  // One-hot encoded
    float y_pred[] = {0.1f, 0.2f, 0.7f, 0.8f, 0.1f, 0.1f};  // Predicted probabilities
    float expected[] = {0.223776f};  // Cross-entropy loss
    
    TensorShape shape = {2, 3, 0, 0};
    
    Tensor true_tensor = create_tensor_from_data(shape, y_true, false);
    Tensor pred_tensor = create_tensor_from_data(shape, y_pred, false);
    
    Tensor result = nn_crossentropy(true_tensor, pred_tensor);
    
    ASSERT_TENSOR_EQ(expected, result, 1, "Cross-entropy loss failed");
    return true;
}

bool test_nn_linear(void) {
    // Reference data from PyTorch
    float input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};  // 2x3
    float weight[] = {0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f};  // 3x2
    float bias[] = {0.1f, 0.2f};  // 2
    float expected[] = {1.5f, 1.8f, 3.3f, 4.2f};  // 2x2
    
    TensorShape input_shape = {2, 3, 0, 0};
    TensorShape weight_shape = {3, 2, 0, 0};
    TensorShape bias_shape = {2, 0, 0, 0};
    
    Tensor input_tensor = create_tensor_from_data(input_shape, input, false);
    Tensor weight_tensor = create_tensor_from_data(weight_shape, weight, false);
    Tensor bias_tensor = create_tensor_from_data(bias_shape, bias, false);
    
    Tensor result = nn_linear(input_tensor, weight_tensor, bias_tensor);
    
    ASSERT_TENSOR_EQ(expected, result, 4, "Linear layer failed");
    return true;
}

// Test suite runners
bool test_arithmetic_operations(void) {
    printf("=== Testing Arithmetic Operations ===\n");
    
    RUN_TEST(test_tensor_add);
    RUN_TEST(test_tensor_sub);
    RUN_TEST(test_tensor_mul);
    RUN_TEST(test_tensor_add_scalar);
    RUN_TEST(test_tensor_mul_scalar);
    
    return true;
}

bool test_matrix_operations(void) {
    printf("=== Testing Matrix Operations ===\n");
    
    RUN_TEST(test_tensor_matmul);
    
    return true;
}

bool test_reduction_operations(void) {
    printf("=== Testing Reduction Operations ===\n");
    
    RUN_TEST(test_tensor_sum);
    RUN_TEST(test_tensor_mean);
    RUN_TEST(test_tensor_argmax);
    
    return true;
}

bool test_activation_functions(void) {
    printf("=== Testing Activation Functions ===\n");
    
    RUN_TEST(test_nn_relu);
    RUN_TEST(test_nn_softmax);
    
    return true;
}

bool test_loss_functions(void) {
    printf("=== Testing Loss Functions ===\n");
    
    RUN_TEST(test_nn_crossentropy);
    
    return true;
}

bool test_neural_network_operations(void) {
    printf("=== Testing Neural Network Operations ===\n");
    
    RUN_TEST(test_nn_linear);
    
    return true;
}